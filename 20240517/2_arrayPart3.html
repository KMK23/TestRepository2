<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    //1. forEach()함수 ⭐⭐⭐
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한다.
    document.write(`<h1>1. forEach() 함수⭐⭐⭐</h1>`);
    const arr = [1, true, "Javascript"];
    document.write(`[${arr}]`);
    function printArr(value, index, array) {
      console.log(`value: ${value}, index: ${index}, array: ${array}`);
    }
    arr.forEach(printArr);
    // console.log(typeof printArr);
    // ()가 없으면 함수 자체를 의미
    // console.log(typeof printArr());
    //이렇게 쓰면 그 자리에서 바로 실행시킨다. 그래서 ()를 빼야해.

    //2. map() 함수 ⭐⭐⭐⭐⭐
    // 해당 배열의 모든 요소에 대하여 반복적으로 명시된 함수를 ⭐실행한 후⭐,
    // 그 실행 결과를 새로운 배열에 담아 반환한다.
    const arr2 = [3, 4, 5, 6];
    const arr3 = [];
    // for (let i = 0; i < arr2.length; i++) {
    //   arr3.push(arr2[i] * 2);
    // }
    // console.log(arr3);
    // arr2.forEach(function (v) {
    //   arr3.push(v * 2);
    // });
    // let emptyArr = [];
    let modifiedArr = arr2.map(function (element, index, array) {
      return element * 2;
    });
    document.write(`<h1>2. map() 함수⭐⭐⭐⭐⭐</h1>`);
    document.write(`<h4>arr2: [${arr2}]</h4>`);
    document.write(`<h4>arr2의 원소에 *2 : [${modifiedArr}]</h4>`);

    // emptyArr = arr2.map((v) => v * 2);

    const users = [
      { firstName: "베컴", lastName: "데이비드" },
      { firstName: "더브라위너", lastName: "케빈" },
      { firstName: "홀란드", lastName: "엘링" },
    ];

    //["데이비드 베컴", "케빈 더브라위너", "엘링 홀란드"]

    const nameArr = users.map(function (v) {
      return `${v.lastName} ${v.firstName}`;
    });
    document.write(`<h4>nameArr : [${nameArr}]</h4>`);
    const numberArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    function multiplyThree(number) {
      return number * 3;
    }
    const newNumberArr = numberArr.map(multiplyThree);
    document.write(`<h4>numberArr : [${numberArr}]</h4>`);
    document.write(`<h4>newNumberArr : [${newNumberArr}]</h4>`);

    // multiplyTree(1)
    // multiplyTree(2)
    // multiplyTree(3)
    // multiplyTree(4)
    // multiplyTree(5) .... 이렇게 10까지 가서 한개씩 함수 실행했어
    // 그러면 총 10번이지 그렇게 하는게 맵함수라고

    //연습문제.
    const doubleArr = [
      [1, 2, 3],
      [4, 5, 6],
      [7, 8, 9],
    ];
    // [6, 15, 24]
    function add(number) {
      let sum = 0;
      for (let i = 0; i < number.length; i++) {
        sum += number[i];
      }
      return sum;
    }
    // const num1 = sum([1, 2, 3]);
    // const num2 = sum([4, 5, 6]);
    // const num3 = sum([7, 8, 9]);
    const newaa = doubleArr.map(add);
    console.log(newaa);

    ////다른 예제 (map 함수)
    const numArr = [5, 10, 15, 20];
    [0, 5, 10, 15];

    // const tempArr = [];
    // for (let k = 0; k < numArr.length; k++) {
    //   tempArr.push(numArr[k] - 5);
    // }
    const GJ = numArr.map(function (v) {
      return v - 5;
    });
    console.log(GJ);

    //다른 예제
    const strArr = ["apple", "banana", "watermelon"];
    //[5, 6, 10]

    const JG = strArr.map(function (h) {
      return h.length;
    });
    console.log(JG);

    //다른 예제
    const strArr2 = ["hello", "world", "javascript"];
    //["HELLO", "WORLD", "JAVASCRIPT"] touppercase()

    const ky = strArr2.map(function (x) {
      return x.toUpperCase();
    });
    console.log(ky);
    //다른 예제
    const numArr2 = [10, 20, 30, 40, 50];
    //["index 0: 10", "index 1: 20", "index 2: 30", "index 3:40", "index 4: 50"];
    const jk = numArr2.map(function (y, z) {
      return `index${z}:${y}`;
    });
    console.log(jk);
    const user2 = [
      { id: 1, name: "김덕배" },
      { id: 2, name: "최덕배" },
      { id: 3, name: "이덕배" },
    ];
    //["김덕배", "최덕배", "이덕배"]
    const dk = user2.map(function (w) {
      return w.name;
    });
    console.log(dk);
    const user3 = [
      { id: 1, name: "김덕배", contact: { email: "kim@gmail.com" } },
      { id: 2, name: "최덕배", contact: { email: "choi@gmail.com" } },
      { id: 3, name: "이덕배", contact: { email: "lee@gmail.com" } },
    ];
    //["kim@gmail.com", "choi@gmail.com", "lee@gmail.com"]

    const kd = user3.map(function (s) {
      return s.contact.email;
    });
    console.log(kd);

    // [1, 2, 3],
    // [4, 5, 6],
    // [7, 8, 9],
    // 결과 ==> [[2,4,6],[8,10,12],[14,16,18]]

    // const aop = doubleArr.map(function (xg) {
    //   const newArr = [];
    //   for (let i = 0; i < xg.length; i++) {
    //     newArr.push(xg[i] * 2);
    //   }
    //   return newArr;
    // });
    // console.log(aop);

    const ll = doubleArr.map(function (v) {
      return v.map(function (v) {
        return v * 2;
      });
    });
    console.log(ll);

    //3. filter()함수 ⭐⭐⭐⭐
    //배열의 모든 요소에 대하여 반복적으로 명시된 함수를 실행한 후,
    //그 결과값이 true 인 요소들만을 새로운 배열로 반환한다.
    document.write(`<h1>3. filter()함수⭐⭐⭐⭐</h1>`);
    const numberArr2 = [1, 2, 3, 4, 5];
    // if (numberArr2 > 3) {
    //   const ak = numberArr2.map(function (ka) {
    //     return;
    //   });
    // }

    // console.log(ak);

    //이렇게 쓰던 것을
    const newArr10 = [];
    for (let i = 0; i < numberArr2.length; i++) {
      if (numberArr2[i] > 3) {
        newArr10.push(numberArr2[i]);
      }
    }
    console.log(newArr10);
    //filter를 이용하면 이렇게 쓸수 있다.
    const result = numberArr2.filter(function (v) {
      return v > 3;
    });
    document.write(`<h4>numberArr2 : [${numberArr2}]</h4>`);
    document.write(`<h4>result : [${result}]</h4>`);
    // result = numberArr2.fultter(element, index, array) 값이 들이간다.

    //예제
    const guys = [
      { name: "덕배", money: 500000 },
      { name: "베컴", money: 700000 },
      { name: "홀란드", money: 600000 },
      { name: "포든", money: 400000 },
    ];
    //money가 500000 만 보다 큰 애들만 배열로 만들고 싶다.

    const newA = guys.filter(function (v) {
      return v.money > 500000;
    });
    // document.write(`<h4>${newA}</h4>`);
    console.log(newA);
    const richNewA = guys.filter(function (v) {
      return v.money > 500000 && v.name == "홀란드";
    });
    console.log(richNewA);

    //4.reduce
    //해당 배열의 모든 요소를 하나의 값으로 줄이기 위해
    //두개의 인수를 전달받는 함수를 실행한다.
    //이때 명시된 함수에 배열의 첫번째요소와 두번째요소를 인수로 전달하고 실행한다.
    //그 결과 반환된 결과값에 세번째 요소를 다시 인수로 전달하고 실행한다.
    document.write(`<h1>4. reduce()함수⭐⭐⭐</h1>`);
    const blankArr = [1, 2, 3, 4, 5];
    const result2 = blankArr.reduce(function (x, y) {
      return x + y;
    });
    //1+2 이 결과가 다음 x로 들어감. y는 3이 들어기고 그런식으로 계속 더한다.
    //1+2+3+4+5
    document.write(`<h4>원본 배열 : [${blankArr}]</h4>`);
    document.write(`<h4>reduce 결과 : [${result2}]</h4>`);
    const result3 = blankArr.reduce(function (x, y) {
      return x - y;
    });
    // 1-2-3-4-5
    document.write(`<h4>reduce 결과 : [${result3}]</h4>`);

    //reduce는 원래 4개의 파라미터를 받는다.

    //1. accmulator : 누산기, 누적값
    //2. currentValue : 처리할 현재 요소
    //3. currentIndex : 처리할 현재 요소의 인덱스
    //4. array : 대상 배열 전체
    //array.reduce(function(acc, cur, idx, arr){

    // }, initialValue(초기값. 위에는 1이 된다.
    // 안써줬기 때문에, 초기값을 줬을 경우 그값이 x자리. 1이 y자리로 들어가겠지))

    //5.reduceRight()함수
    //reduece()함수와 같은 방식으로 실행 되며, 배열의 마지막 요소부터 줄이기 시작한다.

    const result4 = blankArr.reduceRight(function (x, y) {
      return x - y;
    });
    document.write(`<h4>reduceRight 결과: [${result4}]</h4>`);
    //5-4-3-2-1
    // function rhq(ap) {
    //   for (let b = 0; b < ap.length; b++) {
    //     let sum = 0;
    //     sum = ap[b] * 2;
    //   }
    //   return sum;
    // }
    // const ll = doubleArr.map(rhq);
    // console.log(ll);
  </script>
</html>
